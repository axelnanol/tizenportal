import terser from '@rollup/plugin-terser';
import babel from '@rollup/plugin-babel';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import replace from '@rollup/plugin-replace';
import CleanCSS from 'clean-css';
import { readFileSync, readdirSync, statSync, writeFileSync, existsSync } from 'fs';
import path from 'path';

// Read version from package.json - single source of truth
const pkg = JSON.parse(readFileSync('./package.json', 'utf-8'));
const VERSION = pkg.version;

function getFileSize(filePath) {
  try {
    return statSync(filePath).size;
  } catch (err) {
    return 0;
  }
}

function generateBundleRegistry() {
  var bundlesDir = path.resolve('bundles');
  var outputFile = path.join(bundlesDir, 'registry.generated.js');

  if (!existsSync(bundlesDir)) {
    return;
  }

  var entries = readdirSync(bundlesDir);
  var bundleDirs = [];

  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    var fullPath = path.join(bundlesDir, entry);
    try {
      if (statSync(fullPath).isDirectory()) {
        var mainPath = path.join(fullPath, 'main.js');
        if (existsSync(mainPath)) {
          bundleDirs.push(entry);
        }
      }
    } catch (err) {
      // Ignore invalid entries
    }
  }

  bundleDirs.sort();

  var lines = [];
  lines.push('/**');
  lines.push(' * AUTO-GENERATED FILE â€” DO NOT EDIT MANUALLY');
  lines.push(' * Generated by rollup.config.js based on bundles/ folder contents.');
  lines.push(' */');
  lines.push('');

  var bundleMap = [];
  var bundleMeta = [];
  var bundleManifests = [];
  
  for (var j = 0; j < bundleDirs.length; j++) {
    var name = bundleDirs[j];
    var varName = name.replace(/[^a-zA-Z0-9_$]/g, '_');
    if (varName === 'default') {
      varName = 'defaultBundle';
    }
    var mainSize = getFileSize(path.join(bundlesDir, name, 'main.js'));
    var cssSize = getFileSize(path.join(bundlesDir, name, 'style.css'));
    
    // Load manifest.json if it exists
    var manifestPath = path.join(bundlesDir, name, 'manifest.json');
    var manifest = null;
    if (existsSync(manifestPath)) {
      try {
        var manifestContent = readFileSync(manifestPath, 'utf-8');
        manifest = JSON.parse(manifestContent);
      } catch (err) {
        console.warn('Warning: Failed to parse manifest for bundle "' + name + '":', err.message);
      }
    }
    
    lines.push("import " + varName + " from './" + name + "/main.js';");
    bundleMap.push("  '" + name + "': " + varName);
    bundleMeta.push("  '" + name + "': { jsBytes: " + mainSize + ", cssBytes: " + cssSize + " }");
    
    // Store manifest data (will be attached at runtime)
    if (manifest) {
      bundleManifests.push("  '" + name + "': " + JSON.stringify(manifest));
    }
  }

  lines.push('');
  lines.push('export var bundles = {');
  lines.push(bundleMap.join(',\n'));
  lines.push('};');
  lines.push('');
  lines.push('export var bundleMeta = {');
  lines.push(bundleMeta.join(',\n'));
  lines.push('};');
  lines.push('');
  
  // Add bundleManifests export
  if (bundleManifests.length > 0) {
    lines.push('export var bundleManifests = {');
    lines.push(bundleManifests.join(',\n'));
    lines.push('};');
    lines.push('');
  } else {
    lines.push('export var bundleManifests = {};');
    lines.push('');
  }
  
  lines.push('export var bundleNames = Object.keys(bundles);');
  lines.push('');
  lines.push('export default bundles;');
  lines.push('');

  try {
    writeFileSync(outputFile, lines.join('\n'));
  } catch (err) {
    // Ignore write errors
  }
}

// CSS minifier for bundle styles (keeps output as JS string)
const cssMinifier = new CleanCSS({ level: 2 });
const cssMinifyPlugin = {
  name: 'css-minify',
  transform: function(code, id) {
    if (!id || id.indexOf('.css') === -1) return null;
    try {
      var output = cssMinifier.minify(code);
      if (output.errors && output.errors.length) {
        console.warn('CSS minify errors in ' + id + ': ' + output.errors.join('; '));
      }
      return {
        code: 'export default ' + JSON.stringify(output.styles || '') + ';',
        map: { mappings: '' },
      };
    } catch (err) {
      console.warn('CSS minify failed for ' + id + ': ' + err.message);
      return {
        code: 'export default ' + JSON.stringify(code) + ';',
        map: { mappings: '' },
      };
    }
  },
};

// Shared plugins
const plugins = [
  // Generate bundle registry from bundles/ folder at build time
  {
    name: 'bundle-registry-generator',
    buildStart: function() {
      generateBundleRegistry();
    },
  },
  // Replace __VERSION__ placeholder with actual version from package.json
  replace({
    preventAssignment: true,
    values: {
      '__VERSION__': VERSION,
    },
  }),

  // Minify CSS and import as strings
  cssMinifyPlugin,

  // Resolve imports from node_modules
  nodeResolve({
    browser: true,
    preferBuiltins: false,
  }),

  // Convert CommonJS modules to ES modules
  commonjs({
    include: [/node_modules/],
    transformMixedEsModules: true,
  }),

  // Transpile to ES5 for Chrome 47+ compatibility
  babel({
    babelHelpers: 'bundled',
    presets: [
      ['@babel/preset-env', {
        targets: {
          chrome: '47',
        },
        modules: false,
      }],
    ],
    exclude: 'node_modules/**',
  }),

  // Minify for production
  terser({
    ecma: 5,
    mangle: true,
    compress: {
      drop_console: false, // Keep console.log for diagnostics
    },
  }),
];

export default [
  // Build: TizenPortal universal runtime
  {
    input: 'core/index.js',
    output: {
      file: 'dist/tizenportal.js',
      format: 'iife',
      name: 'TizenPortal',
      sourcemap: false,
    },
    plugins,
  },
];